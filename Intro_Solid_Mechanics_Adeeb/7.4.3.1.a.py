from sympy import *
import sympy as sp
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from scipy.interpolate import InterpolatedUnivariateSpline
sp.init_printing(use_latex = "mathjax")
s11, s22, nu, E, h, Svm, t = symbols("\u03c3_{11} \u03c3_{22} nu E h \u03c3_{vM} t")
epmax = 25/100-550/200000
hslope = 150/epmax
print(epmax)
print(hslope)
rule = {E:200000, nu:0.3, h:hslope}
print("Stress, hydrostatic stress, deviatoric stress and von Mises stress")
s33 = 0
s = Matrix([[s11,0,0],[0,s22,0],[0,0,s33]])
hydr = (s11+s22+s33)/3
print("Cauchy stress: ", s)
Sdev = s-hydr*eye(3)
print("Deviatoric stress: ", Sdev)
Sigmavn = sqrt(1/2*((s11-s22)**2+(s11-s33)**2+(s22-s33)**2))
s = simplify(Sigmavn**2)
print(s)
print("The stresses at the elastic limit utilizing ee22=0")
b = solve((sqrt(s) - 400, s22 - s11*nu), (s11,s22))
print(b)
print("The strains at the elastic limit")
ee11=(s11/E-nu*s22/E).subs(s22,nu*s11)
ee22=(-nu*s11/E+s22/E).subs(s22,nu*s11)
ee33=(-nu*s11/E-nu*s22/E).subs(s22,nu*s11)
print(ee11,ee22,ee33)
s11t = Function('\u03c3_{11}')
s22t = Function('\u03c3_{22}')
Sdev = Sdev.subs({s11:s11t(t), s22:s22t(t)})
Sigmavn = Sigmavn.subs({s11:s11t(t), s22:s22t(t)})
print("Consistency condition")
print(Sdev)
ceptp = (3/2*Sdev[0,0]*s11t(t).diff(t)/h/Svm+3/2*Sdev[1,1]*s22t(t).diff(t)/h/Svm)
print(ceptp)
print("ep22 Plastic strain Rate")
cep22tp = simplify(ceptp*3/2*Sdev[1,1]/Svm)
print(cep22tp)
print("ee22 Elastic strain Rate")
ee22tp = s22t(t).diff(t)/E-nu*s11t(t).diff(t)/E
print(ee22tp)
print("Finding the relationship between s11t and s22t")
a = solve(ee22tp + cep22tp, s22t(t).diff(t))
print(a)
print("Making everything a function of s11t alone")
eq1 = eptp = simplify(ceptp.subs(s22t(t).diff(t), a[0]))
eq2 = ep11tp = simplify(ceptp.subs(s22t(t).diff(t), a[0])*3/2*Sdev[0,0]/Svm)
eq3 = ep22tp = simplify(ceptp.subs(s22t(t).diff(t), a[0])*3/2*Sdev[1,1]/Svm)
eq4 = ep33tp = simplify(ceptp.subs(s22t(t).diff(t), a[0])*3/2*Sdev[2,2]/Svm)
print(eq1, eq2, eq3, eq4)
print("Finding s11 and s22 as a function of t using NDsolve, the procedure  assumes s11=t")
s22equation = a[0].subs(rule)
Svmsubs = Sigmavn.subs(rule)
s11initial = (400/sqrt(1-nu+nu**2)).subs(rule)
print(s22equation, Svmsubs, s11initial)
s22equation = s22equation.subs(Svm,Svmsubs)
s22equ = s22equation.subs({s11t(t):s11, s22t(t):s22, s11t(t).diff(t):1})
def rhs1(y,t):
    f = sp.lambdify([s11, s22], s22equ)
    f = f(y[0],y[1])
    ds22tdt = f
    dss11tdt = 1
    return [dss11tdt,ds22tdt]
s11initial = float(s11initial)
t1 = np.linspace(s11initial,650,20)
s22t0 = nu.subs(rule)*s11initial
s11t0 = s11initial
yzero = [s11t0,s22t0]
ff = odeint(rhs1, yzero, t1)
# print(ff)
# plot results
# aa is for plot1
lambda1 = lambda t : t*nu.subs(rule)
xL = np.linspace(0,s11initial,2)
fig, ax = plt.subplots(6,2, figsize = (20,30))
plt.setp(ax[0,0], xlabel = "s11", ylabel = "s22")
ax[0,0].plot(ff[:,0],ff[:,1],'b-')
ax[0,0].plot(xL,lambda1(xL),'b-')
def integralsolve(eq, ff):
    eq = eq.subs(Svm,Svmsubs)
    eptp = eq.subs({s11t(t):s11, s22t(t):s22, s11t(t).diff(t):1, nu:0.3, h:hslope, E:200000})
    f = sp.lambdify([s11,s22], eptp)
    sol = f(ff[:,0],ff[:,1])
    f2 = InterpolatedUnivariateSpline(ff[:,0],sol, k=1)     
    return [f2.integral(s11initial,ff[i,0]) for i in range(20)]
epfunction = integralsolve(eq1, ff)
plt.setp(ax[4,0], xlabel = "s11", ylabel = "e11")
ax[4,0].plot(ff[:,0],epfunction,'b-')
ax[4,0].plot(xL,[0,0], 'b-')
ep11function = integralsolve(eq2, ff)
plt.setp(ax[0,1], xlabel = "s11", ylabel = "ep11")
ax[0,1].plot(ff[:,0],ep11function,'b-')
ax[0,1].plot(xL,[0,0], 'b-')
ep22function = integralsolve(eq3, ff)
plt.setp(ax[0,1], xlabel = "s11", ylabel = "ep22")
ax[1,0].plot(ff[:,0],ep22function,'b-')
ax[1,0].plot(xL,[0,0], 'b-')
ep33function = integralsolve(eq4, ff)
plt.setp(ax[0,1], xlabel = "s11", ylabel = "ep33")
ax[1,1].plot(ff[:,0],ep33function,'b-')
ax[1,1].plot(xL,[0,0], 'b-')
# Now eefunctions
ee11function = (s11/E - s22/E*nu).subs(rule)
ee11_1 = sp.lambdify([s11, s22], ee11function)
sol_ee11 = ee11_1(ff[:,0],ff[:,1])
lambda2 = lambdify(t,(t/E-0.3*t/E*nu).subs(rule))
plt.setp(ax[2,0], xlabel = "s11", ylabel = "ee11")
ax[2,0].plot(ff[:,0],sol_ee11,'b-')
ax[2,0].plot(xL,lambda2(xL),'b-')
ee22function = (-nu*s11/E + s22/E).subs(rule)
ee22_1 = sp.lambdify([s11, s22], ee22function)
sol_ee22 = ee22_1(ff[:,0],ff[:,1])
#lambda3 = lambdify(t,((-nu*t)/E + (0.3*t)/E).subs(rule))
plt.setp(ax[2,1], xlabel = "s11", ylabel = "ee22")
ax[2,1].plot(ff[:,0],sol_ee22,'b-')
ax[2,1].plot(xL,[0,0],'b-')
ee33function = (-nu*s11/E - nu*s22/E).subs(rule)
ee33_1 = sp.lambdify([s11, s22], ee33function)
sol_ee33 = ee33_1(ff[:,0],ff[:,1])
lambda4 = lambdify(t,(-nu*t/E - nu*0.3*t/E).subs(rule))
plt.setp(ax[3,0], xlabel = "s11", ylabel = "ee33")
ax[3,0].plot(ff[:,0],sol_ee33,'b-')
ax[3,0].plot(xL,lambda4(xL),'b-')
plt.setp(ax[3,1], xlabel = "s11", ylabel = "e11")
ax[3,1].plot(ff[:,0],sol_ee11 + ep11function,'b-')
ax[3,1].plot(xL,lambda2(xL),'b-')
plt.setp(ax[4,1], xlabel = "s11", ylabel = "e22")
ax[4,1].plot(ff[:,0],sol_ee22 + ep22function,'b-')
ax[4,1].plot(xL,[0,0],'b-')
ax[4,1].set_ylim([-1,1])
plt.setp(ax[5,1], xlabel = "s11", ylabel = "e33")
ax[5,1].plot(ff[:,0],sol_ee33 + ep33function,'b-')
ax[5,1].plot(xL,lambda4(xL),'b-')
for i in range(6):
    for j in range(2):
        ax[i,j].grid(True,which='both')
        ax[i,j].axvline(x=0,color='k',alpha=0.5)
        ax[i,j].axhline(y=0,color = 'k',alpha=0.5)
plt.show()
